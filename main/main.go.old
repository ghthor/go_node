package main

import (
	"fmt"
	"net"
	"os"
	"runtime"
	"rand"
	//"container/vector"
	//"container/list"
	//"rand"
	//i "ghthor/init"
	//"ghthor/node"
	bufNode "ghthor/node/buffer"
)

func Errored(e os.Error, mesg string) bool {
	if(e != nil) {
		fmt.Printf("Errored %s\n",mesg)
		fmt.Println(e.String())
		return true
	}
	return false
}

type Msg struct {
	prior int
}

func main() {
	runtime.GOMAXPROCS(2)
	ts, _, _ := os.Time()
	fmt.Printf("TimeSec: %v\n", ts)
	rand.Seed(ts)
	fmt.Printf("\n\n");

	in := make(chan Msg)
	bufferIn := make(chan Msg)
	numPrior := 3
	prChans := make([](chan Msg), numPrior)
	for i := 0; i < numPrior; i++ {
		prChans[i] = make(chan Msg, 20)
		defer close(prChans[i])
	}

	defer close(in)
	defer close(bufferIn)

	// Feed the Buffer
	go func() {
		for !closed(bufferIn) {
			select {
				case bufferIn <- Msg{rand.Intn(numPrior)}:
				case bufferIn <- Msg{rand.Intn(numPrior)}:
			}
		}
	}()

	// Fill Buffer with 10 Msgs
	for i := 0; i < 10; i++ {
		msg := <-bufferIn
		prChans[msg.prior] <- msg
	}

	go func() {
		for !closed(in) {
			select {
				case msg := <-prChans[0]:
				default:
				select {
					case msg := <-prChans[1]:
					default:
					select {
						case msg := <-prChans[2]:
						default:
					}
				}
			}
		}
	}()

	go func() {
		for !closed(in) {
			msg := <-in
			fmt.Printf("MsgPrior: %v\n", msg.prior)
		}
	}()

	listenAddr, err := net.ResolveTCPAddr("localhost:52000")
	if Errored(err, "Resolving TCP Addr") { return }

	fmt.Println("Listening For Connections")
	tcpServer, err := net.ListenTCP("tcp4",listenAddr)
	if Errored(err, "Starting to Listen for Connections") { return }

	fmt.Println("Waiting on Connection")
	socket, err := tcpServer.AcceptTCP()
	if Errored(err, "While Accepting TCP Connection") { return }
	tcpServer.Close()

	data := make([]byte, 4)
	fmt.Println("Waiting For Kill Signal")
	bytesRead, err := socket.Read(data)
	fmt.Printf("BytesRead: %v", bytesRead)
	if Errored(err, "While Waiting for the kill Signal") { return }
	socket.Close()

	fmt.Printf("\n\n");
}
